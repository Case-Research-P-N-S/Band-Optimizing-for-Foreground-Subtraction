import numpy as np

# xi = x's from xlist
# yi = y's from ylist
# Yj(xi) = Yth function for x
# Si = error in measured y

# Creating some test values for the YLists. The YList will be an array of values generated by Y functions from the input xList
'''
Y1 Function
    range Y1
Y2 Function 
    range Y2
Y3 Function 
    range Y3
Y4 Function 
    range Y4
'''
#------------------------------------------
# Creating Test Data


# making a test xList and errorYList
xList = [x for x in range(1000)]
errorYList = [np.random.normal(0, 4) for y in range(1000)]

# creating test Ylists. These arrays will actually be generated from given functions Y1, Y2, Y3, Y4, etc.
Y1List = [np.random.normal(0, 4) for i in range(5)]
Y2List = [np.random.normal(1, 6) for i in range(5)]
Y3List = [np.random.normal(4, 2) for i in range(5)]
Y4List = [np.random.normal(0, 3) for i in range(5)]

# Creating test y-ranges
rangeY1 = [-1,3]
rangeY2 = [4,7]
rangeY3 = [2,3]
rangeY4 = [0,10]


#------------------------------------------
# Matrix Function


# this just makes it easier to refer to all the YLists
YList = [Y1List, Y2List, Y3List, Y4List]
YRange = [rangeY1, rangeY2, rangeY3, rangeY4]

def matrixFunction(functionList, functionRanges, errorYList, xList):
    xMax = max(xList)
    xMin = min(xList)
    xStep = xList[1]-xList[0]       #other possible way of calculating if xList is not integer list = (xMax - xMin) / rows
    columns = len(functionList)
    rows = len(xList)
    resultMatrix = np.empty([columns, rows])
    
    for function, yRange in zip(functionList, functionRanges):
        #this creates 3 temp lists which will be recombined for the final YLists so that there are 0s in the undefined areas
        tempA = [0 for i in np.arange(xMin, yRange[0], xStep)]
        tempB = [y for y in function]
        tempC = [0 for i in np.arange(yRange[1], xMax, xStep)]
        functionListAdj = tempA + tempB + tempC
        
    for i in range(columns):
        for j in range(rows):
            s = errorYList[j]
            np.append(resultMatrix, [function/s for function in functionListAdj])
    return resultMatrix

print matrixFunction(YList, YRange, errorYList, xList)
